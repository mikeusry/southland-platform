---
/**
 * CloudinaryImage Component
 *
 * Enhanced image component with Cloudinary optimization, lazy loading,
 * placeholder support, and error handling.
 *
 * Features:
 * - Automatic format optimization (WebP, AVIF)
 * - Responsive srcset generation
 * - Intersection observer lazy loading
 * - Blur-up placeholder technique
 * - Error state fallback
 * - Image effects support
 *
 * @example
 * <CloudinaryImage
 *   publicId="podcast/episode-01"
 *   alt="Episode thumbnail"
 *   width={800}
 *   height={450}
 *   placeholder="blur"
 * />
 */

import {
  buildCloudinaryUrl,
  getCloudinaryResponsiveSet,
  buildPlaceholderUrl,
  getDprSrcset,
  validatePublicId,
  validateDimensions
} from '../lib/cloudinary';
import type { CloudinaryTransformOptions, ImageEffect, CropMode, Gravity, ImageFormat, Quality } from '../lib/cloudinary';

export interface Props {
  /** Cloudinary public ID of the image (required) */
  publicId: string;
  /** Alt text for accessibility (required) */
  alt: string;
  /** Desired width in pixels */
  width?: number;
  /** Desired height in pixels */
  height?: number;
  /** Crop/resize mode */
  crop?: CropMode;
  /** Image quality */
  quality?: Quality;
  /** Image format */
  format?: ImageFormat;
  /** Gravity/focus point */
  gravity?: Gravity;
  /** Image effects */
  effect?: ImageEffect | ImageEffect[];
  /** Border radius (number or 'max' for circle) */
  radius?: number | 'max';
  /** Additional CSS classes */
  class?: string;
  /** Enable responsive images */
  responsive?: boolean;
  /** Custom widths for responsive srcset */
  responsiveWidths?: number[];
  /** Custom sizes attribute */
  sizes?: string;
  /** Loading strategy */
  loading?: 'lazy' | 'eager';
  /** Fetch priority for LCP images */
  fetchpriority?: 'high' | 'low' | 'auto';
  /** Placeholder type */
  placeholder?: 'blur' | 'color' | 'none';
  /** Placeholder color (hex without #) */
  placeholderColor?: string;
  /** Fallback image on error */
  fallbackSrc?: string;
  /** Enable intersection observer for lazy loading */
  observeLazy?: boolean;
  /** Use DPR-based srcset instead of width-based */
  useDprSrcset?: boolean;
  /** Object-fit style */
  objectFit?: 'cover' | 'contain' | 'fill' | 'none' | 'scale-down';
  /** Object-position style */
  objectPosition?: string;
  /** Additional inline styles */
  style?: string;
  /** Data attributes */
  [key: `data-${string}`]: string | undefined;
}

const {
  publicId,
  alt,
  width,
  height,
  crop = 'fill',
  quality = 'auto',
  format = 'auto',
  gravity = 'auto',
  effect,
  radius,
  class: className = '',
  responsive = true,
  responsiveWidths = [400, 800, 1200, 1600],
  sizes,
  loading = 'lazy',
  fetchpriority,
  placeholder = 'blur',
  placeholderColor = 'f5f5f5',
  fallbackSrc,
  observeLazy = true,
  useDprSrcset = false,
  objectFit,
  objectPosition,
  style: customStyle,
  ...dataAttrs
} = Astro.props;

// Validate required props
const isValid = validatePublicId(publicId) && validateDimensions(width, height);

// Build transformation options
const transformOptions: CloudinaryTransformOptions = {
  width,
  height,
  crop,
  quality,
  format,
  gravity,
  effect,
  radius
};

// Generate image URLs
let src: string;
let srcset: string | undefined;
let sizesAttr: string | undefined;
let placeholderSrc: string | undefined;

if (isValid) {
  if (useDprSrcset && width) {
    // DPR-based srcset for fixed-size images
    src = buildCloudinaryUrl(publicId, transformOptions);
    srcset = getDprSrcset(publicId, width, { ...transformOptions, width: undefined });
  } else if (responsive && width) {
    // Width-based responsive srcset
    const responsiveSet = getCloudinaryResponsiveSet(
      publicId,
      responsiveWidths,
      { ...transformOptions, width: undefined }
    );
    src = responsiveSet.src;
    srcset = responsiveSet.srcset;
    sizesAttr = sizes || responsiveSet.sizes;
  } else {
    // Single image URL
    src = buildCloudinaryUrl(publicId, transformOptions);
  }

  // Generate placeholder
  if (placeholder === 'blur') {
    placeholderSrc = buildPlaceholderUrl(publicId, { type: 'blur' });
  } else if (placeholder === 'color') {
    placeholderSrc = `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 ${width || 100} ${height || 100}'%3E%3Crect fill='%23${placeholderColor}' width='100%25' height='100%25'/%3E%3C/svg%3E`;
  }
} else {
  // Fallback for invalid props
  src = fallbackSrc || `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 ${width || 100} ${height || 100}'%3E%3Crect fill='%23f5f5f5' width='100%25' height='100%25'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' fill='%23999' font-size='14'%3EImage%3C/text%3E%3C/svg%3E`;
}

// Build style string
const styleProps: string[] = [];
if (width && height) styleProps.push(`aspect-ratio: ${width} / ${height}`);
if (objectFit) styleProps.push(`object-fit: ${objectFit}`);
if (objectPosition) styleProps.push(`object-position: ${objectPosition}`);
if (customStyle) styleProps.push(customStyle);
const styleString = styleProps.length > 0 ? styleProps.join('; ') : undefined;

// Extract data attributes
const dataAttributes = Object.entries(dataAttrs)
  .filter(([key]) => key.startsWith('data-'))
  .reduce((acc, [key, value]) => ({ ...acc, [key]: value }), {});

// Generate unique ID for intersection observer
const imageId = `cld-img-${Math.random().toString(36).slice(2, 9)}`;
---

{placeholder !== 'none' && observeLazy && loading === 'lazy' ? (
  <!-- Lazy loaded with placeholder -->
  <div
    class:list={['cloudinary-image-wrapper relative overflow-hidden', className]}
    style={styleString}
    {...dataAttributes}
  >
    <!-- Placeholder (shown while loading) -->
    <img
      src={placeholderSrc}
      alt=""
      aria-hidden="true"
      class="cloudinary-placeholder absolute inset-0 w-full h-full object-cover transition-opacity duration-300"
      style="filter: blur(20px); transform: scale(1.1);"
    />
    <!-- Actual image -->
    <img
      id={imageId}
      data-src={src}
      data-srcset={srcset}
      src={placeholderSrc}
      sizes={sizesAttr}
      alt={alt}
      width={width}
      height={height}
      loading="lazy"
      decoding="async"
      fetchpriority={fetchpriority}
      class="cloudinary-image w-full h-full object-cover opacity-0 transition-opacity duration-300"
      data-fallback={fallbackSrc}
      onload="this.classList.remove('opacity-0'); this.previousElementSibling?.classList.add('opacity-0');"
      onerror={fallbackSrc ? `this.src='${fallbackSrc}'; this.classList.remove('opacity-0');` : undefined}
    />
  </div>
) : (
  <!-- Standard image (eager or no placeholder) -->
  <img
    src={src}
    srcset={srcset}
    sizes={sizesAttr}
    alt={alt}
    width={width}
    height={height}
    loading={loading}
    decoding="async"
    fetchpriority={fetchpriority}
    class={className}
    style={styleString}
    onerror={fallbackSrc ? `this.src='${fallbackSrc}'` : undefined}
    {...dataAttributes}
  />
)}

{observeLazy && loading === 'lazy' && (
  <script is:inline define:vars={{ imageId }}>
    // Intersection Observer for lazy loading
    if ('IntersectionObserver' in window) {
      const img = document.getElementById(imageId);
      if (img) {
        const observer = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              const target = entry.target;
              const src = target.getAttribute('data-src');
              const srcset = target.getAttribute('data-srcset');

              if (src) target.src = src;
              if (srcset) target.srcset = srcset;

              observer.unobserve(target);
            }
          });
        }, {
          rootMargin: '50px 0px',
          threshold: 0.01
        });

        observer.observe(img);
      }
    } else {
      // Fallback for browsers without IntersectionObserver
      const img = document.getElementById(imageId);
      if (img) {
        const src = img.getAttribute('data-src');
        const srcset = img.getAttribute('data-srcset');
        if (src) img.src = src;
        if (srcset) img.srcset = srcset;
      }
    }
  </script>
)}

<style>
  .cloudinary-image-wrapper {
    background-color: #f5f5f5;
  }

  .cloudinary-placeholder.opacity-0 {
    opacity: 0;
    pointer-events: none;
  }

  .cloudinary-image.opacity-0 {
    opacity: 0;
  }
</style>
